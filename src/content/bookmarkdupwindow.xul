<?xml version="1.0"?>
<?xml-stylesheet type="text/css" href="chrome://global/skin/" ?>

<window
  onload="onLoad();"
  id="bookmarkdup-window"
  title="Bookmark dup"
  orient="horizontal"
  xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">

<script><![CDATA[

// TODO: Select first item in left listbox if deletion causes blank right-list.

var dupList = {};
var bookmarksService = null;
var historyService = null;
var status = null;
var dupCount = 0;
var dupinfo = [];

function onLoad() {
  setStatus("Getting services");
  
  bookmarksService = window.arguments[0].bmService;
  historyService = window.arguments[0].hService;
  
  setStatus("Loading bookmarks");
  findBookmarks();
  setlbDupUrisVals();
  setStatus("Bookmarks loaded. " + dupCount + " duplicates found");
  if (dupCount == 0) {
    window.alert("No duplicates found.");
  }

}

function setStatus(msg, url) {
  var status = document.getElementById("status");
  if (typeof(url) == "undefined") {
    // status.class = "plain";
    status.setAttribute("class", "plain");
  }
  else {
    status.href = url;
    // status.class = "text-link";
    status.setAttribute("class", "text-link");
  }
  status.value = msg;
  // window.alert(status.class);
}

/**
 * Finds all bookmarks and creates the dupe list
 */
function findBookmarks() {
  function queryFolderRec(resultList, baseFolder, path) {
    // Setup new query
    // TODO: can resultList be removed from the argument?
    var query = historyService.getNewQuery();
    query.setFolders([baseFolder], 1);
    var options = historyService.getNewQueryOptions();
    options.queryType = options.QUERY_TYPE_BOOKMARKS;

    var result = historyService.executeQuery(query, options);
    var folderNode = result.root;

    // Fix path attribute
    if (path == "") {
      path = folderNode.title + "/";
    }
    else {
      path = path + folderNode.title + "/";
    }

    folderNode.containerOpen = true; // Open current folder

    for (var i = 0; i < folderNode.childCount; i++) {
      var childNode = folderNode.getChild(i);
      if (childNode.type == childNode.RESULT_TYPE_URI)
      {
        // Bookmark
        var obj = {node: childNode, path: path};
      resultList.push(obj);
      }
      else if (childNode.type == childNode.RESULT_TYPE_FOLDER)
      {
        // Folder
        queryFolderRec(resultList, childNode.itemId, path);
      }
    }
    folderNode.containerOpen = false; // Close current folder
  }

  // Query all three folder groups
  var resultList = [];
  queryFolderRec(resultList, bookmarksService.toolbarFolder, "");
  queryFolderRec(resultList, bookmarksService.bookmarksMenuFolder, "");
  queryFolderRec(resultList, bookmarksService.unfiledBookmarksFolder, "");

  // Sort the URI's for easy duplicate check
  resultList.sort( function(a,b) {
    if (a.node.uri < b.node.uri) return -1;
    if (a.node.uri > b.node.uri) return 1;
    return 0;
  });

  dupCount = 0;
  dupList = {}; // This contains a list of all duplicate bookmarks, on the form {node: bookmark, path: folderpath}
  for (var i = 0; i < resultList.length - 1; i++) {
    var thisBookmark = resultList[i];
    var nextBookmark = resultList[i+1];

    if (thisBookmark.node.uri == nextBookmark.node.uri) {
      // Dupe found
      dupCount++;
      if (!(thisBookmark.node.uri in dupList)) {
        dupList[thisBookmark.node.uri] = []; // Initialize this dupList[uri] entry
      }
      
      // Add both bookmarks, but check if they are already in the list first
      if (dupList[thisBookmark.node.uri].indexOf(thisBookmark) == -1) {
        dupList[thisBookmark.node.uri].push(thisBookmark);
      }
      if (dupList[thisBookmark.node.uri].indexOf(nextBookmark) == -1) {
        dupList[thisBookmark.node.uri].push(nextBookmark);
      }
      // dupList[uri] = [bookmark_1, bookmark_2, ..., bookmark_n]
    }
  }
}

/**
* Updates the left listbox with duplicate titles
*/
function setlbDupUrisVals() {
  var lbdup = document.getElementById("lbDupUris");
  // Clear list
  for (var i = lbdup.getRowCount()-1; i >= 0; i--) {
    lbdup.removeItemAt(i);
  }

  // Sort items
  var lbitemlist = [];
  for (var uri in dupList) {
    if (typeof(uri) == "undefined") {continue;}
    var title = dupList[uri][0].node.title;
    lbitemlist.push( {title: title, uri: uri} )
  }

  lbitemlist.sort( function(a,b) {
    if (a.title < b.title) return -1;
    if (a.title > b.title) return 1;
    return 0;
  });

  // Populate list
  for (var i = 0; i < lbitemlist.length; i++)
  {
    lbdup.appendItem( lbitemlist[i].title, lbitemlist[i].uri )
  }

}

/**
 * Clear details-listbox
 */
function clearDupDetails() {
  var lbdupdetails = document.getElementById("lbDupDetails");
  // Clear existing values:
  for (var i = lbdupdetails.getRowCount()-1; i >= 0; i--) {
    lbdupdetails.removeItemAt(i);
  }
}

/**
* Updates the right listbox with information for the selected duplicate
*/
function urisel() {
  var lbdup = document.getElementById("lbDupUris");
  var lbdupdetails = document.getElementById("lbDupDetails");
  
  item = lbdup.selectedItem;
  if (item == null) { return; }

  clearDupDetails();

  var uri = item.value;
  var bookmarks = dupList[uri];

  dupinfo = []; // clear dupinfo
  for (var i = 0; i < bookmarks.length; i++)
  {
    var bookmark = bookmarks[i].node;
    var path = bookmarks[i].path;
    var itemText = path;
    var item = lbdupdetails.appendItem( itemText, i);
    dupinfo.push( {itemId: bookmark.itemId, uri: uri} )
  }
}

/**
 * Opens the current uri in a new tab
 */
function openbmark() {
  var lbdup = document.getElementById("lbDupUris");
  item = lbdup.selectedItem;
  if (item == null) { return; }
  uri = item.value;
  window.opener.openUILinkIn(uri, 'tab');
}

/**
 * Deletes the selected bookmarks
 */
function delbmarks() {
  var lbdupdetails = document.getElementById("lbDupDetails");
  var items = lbdupdetails.selectedItems;
  if (items.length == 0) { return; }

  var remove_ids = [];
  var uri = null;
  // Iterate over selected items
  for (var i = 0; i < items.length; i++)Â {
    var item = items[i];
    var itemId = dupinfo[item.value].itemId;
    uri = dupinfo[item.value].uri;
    remove_ids.push(itemId); // Add to list of items to be removed
    
    // Iterate over current dupeList, remove items from that list
    var bookmarks = dupList[uri];
    for (var j = bookmarks.length-1; j >= 0; j--) {
      if (bookmarks[j].node.itemId == itemId) {
        bookmarks.splice(j, 1);
      }
    }    
  }

  // If there is no longer sufficient bookmarks to be a dupe, delete this and deselect this item.
  if (dupList[uri].length <= 1) {
    delete dupList[uri];
    lbdupuris = document.getElementById("lbDupUris");
    clearDupDetails();
    lbdupuris.selectedItem = null;
  }
  else {
    urisel();
  }

  // Delete the actual bookmarks
  for (var i = 0; i < remove_ids.length; i++) {
    bookmarksService.removeItem(remove_ids[i]);
    //window.alert("bookmarksService.removeItem(" + remove_ids[i] + ")");
  }

  var statusMsg = "";
  if (remove_ids.length > 1) {
    statusMsg += remove_ids.length + " x ";
  }
  statusMsg += uri + " has been removed.";
  
  setStatus(statusMsg, uri);
  
  // Update dupe-list
  setlbDupUrisVals();
}


]]></script>

<vbox flex="1">
  <hbox flex="1">
    <listbox width="300px" id="lbDupUris" seltype="single" onselect="urisel();" flex="1">
      <listhead>
        <listheader label="Duplicate (title)"/>
      </listhead>
    </listbox>
    
    <listbox width="300px" id="lbDupDetails" seltype="multiple" flex="1">
    <listhead>
        <listheader label="Bookmarks (location)"/>
      </listhead>
    </listbox>
  </hbox>
  <hbox>
    <spacer flex="1"/>
    <button id="btnDelBmarks" label="Delete" accesskey="D" oncommand="delbmarks();"/>
    <button id="btnOpenBmark" label="Open" accesskey="O" oncommand="openbmark();"/>
  </hbox>
  <hbox>
    <spacer flex="1"/>
    <button id="btnCloseWin" label="Close" accesskey="C" oncommand="close();"/>
  </hbox>

  <label id="status" class="plain" value="Loading..." />
</vbox>
</window>
